<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SaltStack Automation in Qubes OS</title>
<style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
      padding: 20px;
      background-color: #f9f9f9;
      color: #333;
    }
    h1, h3 {
      color: #2c3e50;
    }
    code {
      background-color: #f4f4f4;
      padding: 2px 4px;
      border-radius: 4px;
    }
    pre {
      background-color: #f4f4f4;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow-x: auto;
    }
    ul {
      margin-left: 20px;
    }
</style>
</head>
<body>

  <h2>SaltStack Automation in Qubes OS</h2>

  <h3>Overview</h3>

  <p><strong>SaltStack</strong> is a powerful, flexible automation framework designed for managing system configurations and automating tasks across distributed systems. Integrated into <strong>Qubes OS</strong>, SaltStack helps automate the management of qubes (virtual machines) and the underlying infrastructure, streamlining processes for system configuration, software deployment, and updates.</p>

  <p>SaltStack uses a master-minion model where the <strong>Salt Master</strong> (server) controls and communicates with the <strong>Salt Minions</strong> (clients), making it ideal for distributed environments like Qubes OS, where multiple isolated qubes need coordinated management.</p>

  <h3>Key Concepts in SaltStack Automation:</h3>

  <ul>
  <li><strong>States:</strong>
    <p>SaltStack uses <strong>states</strong> to define the desired configuration of systems. States are written in <strong>YAML</strong>, with optional <strong>Jinja</strong> templating to introduce dynamic content and logic. States ensure that systems are maintained in a specific state (e.g., ensuring a package is installed, a service is running, or a file is present).</p>
    <p><strong>YAML</strong>: Simple and human-readable, YAML is the default language for defining states.</p>
    <p><strong>Jinja</strong>: This templating engine allows for powerful, dynamic configurations by enabling conditional logic, loops, and variable interpolation in Salt states, reducing redundancy and increasing flexibility.</p>
  </li>
  <li><strong>Pillars:</strong>
    <p>Salt’s <strong>pillar</strong> system provides a way to securely distribute data to minions. This is particularly useful for managing sensitive information such as passwords, API keys, or cryptographic secrets. Data is stored on the <strong>Salt Master</strong> and selectively made available to specific minions. Pillars ensure secure, isolated access to sensitive data without exposing it in configuration files.</p>
    <p><strong>Encryption:</strong> Pillar data can be encrypted, ensuring that secrets remain protected even if transmitted across less secure channels.</p>
  </li>
  <li><strong>Modules:</strong>
    <p><strong>Salt modules</strong> are pre-built tools that perform specific tasks (e.g., installing packages, managing services). Minions can access various modules based on their configuration.</p>
    <p><strong>Returners:</strong> A specialized type of module that collects and sends data generated by jobs to external systems like databases, log aggregators, or monitoring systems.</p>
  </li>
  <li><strong>Grains:</strong>
    <p><strong>Grains</strong> are pieces of metadata collected by the Salt Minion about the system it is running on. Information such as the operating system, IP address, memory, or architecture is gathered automatically when the minion starts. Grains enable Salt to make decisions about which configurations should be applied based on the system's properties, allowing for tailored automation based on system characteristics.</p>
    <p><strong>Targeting Minions:</strong> Grains can be used in conjunction with targeting to ensure that commands are sent only to the relevant systems.</p>
  </li>
  <li><strong>Formulas:</strong>
  <p><strong>Salt formulas</strong> are collections of Salt states, typically organized into reusable packages that automate the setup and configuration of complex applications or services. A formula usually includes multiple states, configurations, and files necessary to deploy and manage a specific software stack or service.</p>
  <p><strong>Reusable and Modular:</strong> Formulas provide a modular approach to configuration management, allowing users to easily deploy and reconfigure applications across multiple systems without duplicating efforts.</p>
  <p><strong>Community-Driven:</strong> The SaltStack community maintains a rich library of formulas on GitHub, where users can share, improve, and contribute configurations for common applications. This collaborative environment helps streamline deployment processes and makes it easier to adopt best practices across diverse environments.</p>
  </li>
  </li>
  </ul>

  <h3>Important SaltStack File Extensions</h3>

  <p>SaltStack utilizes various file extensions to manage configurations, sensitive data, and custom functionality. Below are the most important extensions used in SaltStack:</p>

  <ul>
  <li><strong>.sls</strong> – <em>Salt State Files</em>: The most important file type for configuration management. These files define the desired state of systems (e.g., installed packages, running services, etc.).</li>
  <pre><code>example.sls</code></pre>
  <li><strong>top.sls</strong> – <em>Top File</em>: The <a href="https://github.com/QubesOS/qubes-mgmt-salt-base-config/blob/b3d2837/qubes/files/top.sls">top.sls</a> file maps Salt states to specific minions. It defines which states should be applied to which minions or groups of minions in batch.</li>
  <pre><code>top.sls</code></pre>
  <li><strong>.pillar</strong> – <em>Pillar Files</em>: Files that store sensitive and system-specific configuration data, often used to store things like passwords, API keys, and other confidential information.</li>
  <pre><code>example.pillar</code></pre>
  <li><strong>.j2 or .jinja</strong> – <em>Jinja2 Templates</em>: Jinja2 templates are used within SaltStack for dynamic content generation, allowing for flexibility and customization of configurations by embedding logic into configuration files.</li>
  <pre><code>template.j2</code></pre>
  <li><strong>.conf</strong> – <em>Configuration Files</em>: Standard system configuration files (e.g., for services like Nginx or Apache) that SaltStack manages to ensure they are configured correctly across systems.</li>
  <pre><code>nginx.conf</code></pre>
  <li><strong>.py</strong> – <em>Python Files</em>: Custom Python modules are used to extend SaltStack’s functionality, allowing you to write custom execution modules, returners, or states.</li>
  <pre><code>custom_module.py</code></pre>
  </ul>

  <h3>SaltStack State Functions</h3>

  <p>SaltStack provides several commands for applying states to minions. These functions allow for flexible and powerful configuration management in SaltStack, enabling you to apply configurations across many systems efficiently. These functions help manage the application of those configurations:</p>

  <ul>
    <li><strong>state.sls</strong>: Applies a specific state file located in <code>/srv/user_salt/</code> to a qube/minion. This is useful when you want to apply one or more states explicitly without using the top file.</li>
    <pre><code>sudo qubesctl 'minion_id' state.sls my_state saltenv=user</code></pre>
    <p>When we run individual states from the user directory, we need to user the argument <code>saltenv=user</code>.</p>
    <li><strong>state.top</strong>: Refers to the <code>top.sls</code> file, which defines which states apply to which minions. It can be run directly, but is usually used in conjunction with <code>state.highstate</code>.</li>
    <li><strong>state.highstate</strong>: Applies all states defined in the <code>top.sls</code> file for a minion. This is typically used to apply all configurations specified in the top file.</li>
    <pre><code>sudo qubesctl state.highstate</code></pre>
    <pre><code>sudo qubesctl --skip-dom0 --targets='minion_id' state.highstate</code></pre>
    <pre><code>sudo qubesctl --skip-dom0 --targets='minion_id' state.highstate test=True</code></pre>
    <li><strong>state.apply</strong>: Applies a specific state or set of states to a minion. Use this to apply a configuration directly from a state file.</li>
    <pre><code>sudo qubesctl --skip-dom0 --targets='minion_id'  state.apply my_state.sls</code></pre>
  </ul>

  <h3>Base Salt Configuration</h3>

  <p>The available Salt status commands are in this directory in <code>dom0</code>:</p>

  <pre><code>/srv/salt/qubes/README.rst</code></pre>

  <p>To activate the <a href="https://github.com/QubesOS/qubes-mgmt-salt-base-config/blob/b3d2837/qubes/user-dirs.sls">user configuration directories</a> for personal state configurations, run the following command in <code>dom0</code>:</p>

  <pre><code>sudo qubesctl state.sls qubes.user-dirs</code></pre>

  <p>This command creates the following folders and files:</p>
  
  <ul>
    <li><code>/srv/user_salt/</code>: Directory that stores user-defined Salt states configuration files.</li>
    <li><code>/srv/user_salt/top.sls</code>: File that defines which states should be applied in batch.</li>
    <li><code>/srv/user_pillar/</code>: Directory that stores pillar data for configurations.</li>
    <li><code>/srv/user_formulas/</code>: Directory that stores custom Salt formulas.</li>
  </ul>
  
  <p>Note: When you uninstall qubes-mgmt-salt, your custom scripts won't be deleted or updated, but their permissions might be adjusted. This means they could become outdated or have issues if not manually updated, and their accessibility might change.</p>

<h3>Adding Custom Policies in Qubes OS</h3>

<p>To add custom policies, we need to create a new Salt policy. We could install applications in a work, personal, or vault AppVM. Let’s build a basic development environment in a work qube, an improved personal qube, and a more secure vault qube.</p>

<ol>
  <li><strong>Create a directory for your policy:</strong> This will be the location where the custom states will reside.</li>
  <pre><code>mkdir -p /srv/user_salt/dev_policy</code></pre>
  
  <li><strong>Create a new Salt state file:</strong> For example, create a state file named <code>dev_tools.sls</code> to install applications like <code>git</code> and <code>curl</code> in the AppVM/qube/minion.</li>
  <pre><code>
  # /srv/user_salt/dev_policy/dev_tools.sls
  install-tools:
    pkg.installed:
      - pkgs:
        - git
        - curl
  </code></pre>

  <li><strong>Create other Salt state files:</strong> For example, create state files for the personal, work, and vault qubes with the respective applications.</li>

  <h4>Personal AppVM</h4>
  <pre><code>
  # /srv/user_salt/personal_policy/personal_apps.sls
  install-personal-tools:
    pkg.installed:
      - pkgs:
        - keepassxc
        - mpv
        - evice
        - xournal
  </code></pre>

  <h4>Work AppVM</h4>
  <pre><code>
  # /srv/user_salt/work_policy/work_apps.sls
  install-work-tools:
    pkg.installed:
      - pkgs:
        - keepassxc
        - cherrytree
        - geany
  </code></pre>

  <h4>Vault AppVM</h4>
  <pre><code>
  # /srv/user_salt/vault_policy/security_tools.sls
  install-vault-tools:
    pkg.installed:
      - pkgs:
        - keepassxc
        - sirikali
  </code></pre>

  <li><strong>Add the new policies to the <code>top.sls</code> file:</strong> The <code>top.sls</code> file tells SaltStack which states to apply to which minions. Add the new policies for your work, personal, and vault AppVMs here.</li>
  
  
  <li>Salt operate in masterless mode in dom0 and its necessary to edit the default config for minions. Beyond the 'base', we actived the 'user', then we need to edit it in <code>f_defaults.conf</code>:</li>
  
  <pre><code>sudo nano /etc/salt/minion.d/f_defaults.conf</code></pre>

  <pre><code>
  (...)
  top_file_merging_strategy: merge
  env_order: ['base', 'user']
  (...)
  </code></pre>
  
  <pre><code>sudo nano /srv/user_salt/top.sls</code></pre>

  <pre><code>
  base:
    'work':
      - work_policy.work_apps
      - dev_policy.dev_tools  # Include dev tools in the work qube
    'personal':
      - personal_policy.personal_apps
    'vault':
      - vault_policy.security_tools
  </code></pre>

  <li><strong>Apply the policy:</strong> After setting up the state and top files, you can apply the policy using the following command to install the applications in the targeted AppVMs.</li>
  <pre><code>sudo qubesctl state.apply</code></pre>
  
  <p>After running this command, the specified packages for each AppVM will be installed as per the configurations in their respective Salt state files.</p>

  <li><strong>Test and verify:</strong> Always verify the changes in each AppVM to ensure the configurations are applied as expected. Use commands like <code>sudo qubesctl state.highstate</code> for broader testing or apply individual states for specific configurations.</li>
</ol>


  <h3>Practical Tips</h3>

  <ul>
    <li>Test new policies in a disposable VM before applying them globally.</li>
    <li>Use descriptive names for your state files and directories.</li>
    <li>Leverage the power of pillars for secure and reusable configurations.</li>
    <li>Use version control (e.g., Git) to manage your Salt states and track changes.</li>
  </ul>

  <h3>References</h3>

  <ul>
    <li><a href="https://forum.qubes-os.org/t/qubes-salt-beginners-guide/20126/40" target="_blank">Qubes Salt Beginner’s Guide - Qubes Community Guides</a></li>
    <li><a href="https://www.qubes-os.org/doc/salt/" target="_blank">Qubes OS SaltStack Documentation</a></li>
    <li><a href="https://docs.saltproject.io/" target="_blank">SaltStack Official Documentation</a></li>
    <li><a href="https://forum.qubes-os.org/t/is-etc-salt-master-used-to-configure-salt-in-qubes-os/20931">Is /etc/salt/master used to configure Salt in Qubes OS?</a></li>
  </ul>

</body>
</html>
